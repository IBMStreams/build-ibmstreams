# SPL_CGT_INCLUDE: InetRetrieverCpp.cgt
# SPL_CGT_INCLUDE: URIHelperCpp.cgt

package InetSource_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   # Copyright (C) 2010,2012-2016, International Business Machines Corporation. 
   # All Rights Reserved.
   print "\n";
   print "\n";
     unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . "/../impl/bin";
     require CodeGenX;
     require InetResource;
   
     my $ccContext = $model->getContext()->getOptionalContext("ConsistentRegion");
     if (defined $ccContext) {
       SPL::CodeGen::exitln(InetResource::INET_CONSISTENT_CHECK("InetSource"));
     }
     
     # get the output port object
     my $outputPort = $model->getOutputPortAt(0);
   
     # the data fetched from URLs will be assigned to the first output attribute that does not have an assignment
     my $dataAttributeName;
     my $dataAttributeType;
       for (my $i = 0; $i < $outputPort->getNumberOfAttributes(); ++$i) {
           my $attribute = $outputPort->getAttributeAt($i);
           next if $attribute->hasAssignment();
           $dataAttributeName = $attribute->getName();
           $dataAttributeType = $attribute->getSPLType();
           last;
       }
     SPL::CodeGen::exit("sorry, fetched data cannot be assigned to an output attribute because all attributes have explicit assignments" ) unless $dataAttributeName;
     SPL::CodeGen::exit(InetResource::INET_OPORT_TYPE_CHECK_2($dataAttributeName, $dataAttributeType)) unless $dataAttributeType eq "rstring" || $dataAttributeType eq "list<rstring>" || $dataAttributeType eq "blob" || $dataAttributeType eq "xml";
   
     # get C++ expressions that get values for optional parameters
     my $timeout = $model->getParameterByName("timeout") ? $model->getParameterByName("timeout")->getValueAt(0)->getCppExpression() : 0;
   
     # create a variable to hold the parameters as I get them
     my $parameter = "";
     my $ignoreURIcheckException = $model->getParameterByName("ignoreURIcheckException");
     my $initDelay = $model->getParameterByName("initDelay");
     my $incrementalFetch = $model->getParameterByName("incrementalFetch");
     my $doNotStreamInitialFetch = $model->getParameterByName("doNotStreamInitialFetch");
     my $unconditionalFetch = $model->getParameterByName("unconditionalFetch");
     my $emitTuplePerFetch = $model->getParameterByName("emitTuplePerFetch");
     my $emitTuplePerURI = $model->getParameterByName("emitTuplePerURI");
     my $emitTuplePerRecordCount = $model->getParameterByName("emitTuplePerRecordCount");
   
     # consistency checks for boolean parameters, based on type of data attribute
   
     if ($dataAttributeType eq "list<rstring>")
     {
       if(!($emitTuplePerFetch) && !($emitTuplePerURI) && !($emitTuplePerRecordCount))
       {
         $emitTuplePerFetch = 1;
       } else {
         if($emitTuplePerFetch) { $emitTuplePerFetch = ($emitTuplePerFetch->getValueAt(0)->getSPLExpression() eq 'true')?1:0; }
         if($emitTuplePerURI) { $emitTuplePerURI = ($emitTuplePerURI->getValueAt(0)->getSPLExpression() eq 'true')?1:0; }
       }
     }
   
     if ($dataAttributeType eq "rstring")
     {
       my $value = $emitTuplePerRecordCount ? $emitTuplePerRecordCount->getValueAt(0)->getSPLExpression() : 1;
       # scalar attributes in output tuple
       if(($emitTuplePerFetch) || ($emitTuplePerURI))
       {
         SPL::CodeGen::exit(InetResource::INET_PARAM_CHECK_3($dataAttributeType));
       }
       elsif ($value > 1)
       {
         SPL::CodeGen::exit(InetResource::INET_PARAM_CHECK_4($value));
       }
     }
   
     if ($ignoreURIcheckException)
     {
       $ignoreURIcheckException = $ignoreURIcheckException->getValueAt(0)->getCppExpression();
     }
     else
     {
       $ignoreURIcheckException ="false";
     }
     if($initDelay)
     {
       $initDelay = $initDelay->getValueAt(0)->getCppExpression();
     }
   
     if($incrementalFetch)
     {
       $incrementalFetch = $incrementalFetch->getValueAt(0)->getCppExpression();
     }
   
     if($doNotStreamInitialFetch)
     {
       $doNotStreamInitialFetch = ($doNotStreamInitialFetch->getValueAt(0)->getSPLExpression() eq 'true')?1:0;
     }
   
     if($unconditionalFetch)
     {
       $unconditionalFetch = $unconditionalFetch->getValueAt(0)->getCppExpression();
     }
   print "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '#include <iostream>', "\n";
   print '#include <string>', "\n";
   print '#include <sstream>', "\n";
   print '#include <cassert>', "\n";
   print '#include <cerrno>', "\n";
   print '#include <fstream>', "\n";
   print '#include <iomanip>', "\n";
   print '#include <getopt.h>', "\n";
   print '#include <sys/socket.h>', "\n";
   print '#include <netdb.h>', "\n";
   print 'using namespace std;', "\n";
   print "\n";
   print '#include <streams_boost/algorithm/string.hpp>', "\n";
   print 'using namespace streams_boost;', "\n";
   print "\n";
   print "\n";
   print '#include <limits.h>', "\n";
   print '#include <stdlib.h>', "\n";
   print "\n";
   print '/*', "\n";
   print '*******************************************************************************', "\n";
   print '* Copyright (C) 2009,2012-2014, International Business Machines Corporation. ', "\n";
   print '* All Rights Reserved. *', "\n";
   print '*******************************************************************************', "\n";
   print '*/', "\n";
   print "\n";
   print '// This file contains the source for InetRetriever.', "\n";
   print '// As it references MY_OPERATOR, it\'s meant to be included in a cgt file.', "\n";
   print "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::InetRetriever(const std::string& url, const int timer) throw(int) :', "\n";
   print '  _targetURL(url),', "\n";
   print '  _timeout(timer)', "\n";
   print '  {', "\n";
   print '    reset();', "\n";
   print '    _ignoreLastModTime = _incrementalFetch = false;', "\n";
   print "\n";
   print '    _curlHandle = curl_easy_init();', "\n";
   print "\n";
   print '    if (NULL == _curlHandle)', "\n";
   print '      {', "\n";
   print '        std::cerr << "InetRetriever: Init returned null curlHandle" << std::endl;', "\n";
   print '        throw 12;', "\n";
   print '      }', "\n";
   print "\n";
   print '#if 0', "\n";
   print '    printf(">>>>>>>>>>>>>>>> retriever for URL %s, timeout=%d\\n", _targetURL.c_str(), _timeout);', "\n";
   print '#endif', "\n";
   print "\n";
   print '    // what to do with returned data - call the class\' static callback method', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_WRITEFUNCTION, consumeData_static);', "\n";
   print "\n";
   print '    // Set the write function\'s user-data (state data).', "\n";
   print '    // Note that passing the "this" pointer allows the static callback method (set above)', "\n";
   print '    // to resolve the particular instance that the callback should be directed to.', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_WRITEDATA, this);', "\n";
   print "\n";
   print '    // Set the URL that we are fetching', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_URL, _targetURL.c_str());', "\n";
   print "\n";
   print '    // Tell curl to follow any redirects for the URL that the server returns', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_FOLLOWLOCATION, 1L);', "\n";
   print "\n";
   print '    // Tell curl to ask the server to provide the "last modified at" timestamp when fetching a file', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_FILETIME, 1);', "\n";
   print "\n";
   print '    // accept all supported built-in compression methods', "\n";
   print '#ifdef CURLOPT_ACCEPT_ENCODING', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_ACCEPT_ENCODING, "");', "\n";
   print '#elseif CURLOPT_ENCODING', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_ENCODING, "");', "\n";
   print '#endif', "\n";
   print "\n";
   print '    // some servers insist on knowing who is asking', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_USERAGENT, "IBMStreams/4.0");', "\n";
   print "\n";
   print '    // set timeout, if specified', "\n";
   print '    if (_timeout) {', "\n";
   print '      curl_easy_setopt(_curlHandle, CURLOPT_NOSIGNAL, 1);', "\n";
   print '      curl_easy_setopt(_curlHandle, CURLOPT_TIMEOUT, _timeout);', "\n";
   print '    } ', "\n";
   print '  }', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::~InetRetriever()', "\n";
   print '  {', "\n";
   print '    curl_easy_cleanup(_curlHandle);', "\n";
   print '  }', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::fetch() throw(CURLcode)', "\n";
   print '  {', "\n";
   print "\n";
   print '    // function result will be stored here', "\n";
   print '    std::string result;', "\n";
   print "\n";
   print '    // clear state variables for other results that can be assigned to output attributes', "\n";
   print '    _curlBuffer.clear();', "\n";
   print '    _dataCameBack = false;', "\n";
   print '    _bytesTransferredLastFetch = 0;', "\n";
   print '    _responseCode = 0;', "\n";
   print '    _fetchTime = 0;', "\n";
   print '    _effectiveURL.clear();', "\n";
   print '    _contentType.clear();', "\n";
   print "\n";
   print '    // Unless requested, don\'t retrieve again if unmodified since last retrieval', "\n";
   print '    if (!_ignoreLastModTime && _lastModTime>0)', "\n";
   print '      {', "\n";
   print '        // Tell curl to not retrieve the file if it hasn\'t changed since our last retrieval', "\n";
   print '        curl_easy_setopt(_curlHandle, CURLOPT_TIMECONDITION, CURL_TIMECOND_IFMODSINCE);', "\n";
   print '        curl_easy_setopt(_curlHandle, CURLOPT_TIMEVALUE, _lastModTime);', "\n";
   print '      }', "\n";
   print '    else', "\n";
   print '      {', "\n";
   print '        // Tell curl to retrieve the file regardless of whether it has changed since our last', "\n";
   print '        // retrieval', "\n";
   print '        curl_easy_setopt(_curlHandle, CURLOPT_TIMECONDITION, CURL_TIMECOND_NONE);', "\n";
   print '      }', "\n";
   print "\n";
   print '    // "Engage." - J.L. Picard', "\n";
   print '    CURLcode rc1 = curl_easy_perform(_curlHandle);', "\n";
   print "\n";
   print '    if (CURLE_OK == rc1)', "\n";
   print '      {', "\n";
   print '        if (_dataCameBack) // data came back', "\n";
   print '          {', "\n";
   print '            CURLcode rc2;', "\n";
   print "\n";
   print '            char* effectiveURL = NULL;', "\n";
   print '            rc2 = curl_easy_getinfo(_curlHandle, CURLINFO_EFFECTIVE_URL, &effectiveURL);', "\n";
   print '            if (rc2==CURLE_OK && effectiveURL) _effectiveURL = effectiveURL;', "\n";
   print "\n";
   print '            char* contentType = NULL;', "\n";
   print '            rc2 = curl_easy_getinfo(_curlHandle, CURLINFO_CONTENT_TYPE, &contentType);', "\n";
   print '            if (rc2==CURLE_OK && contentType) _contentType = contentType;', "\n";
   print "\n";
   print '            curl_easy_getinfo(_curlHandle, CURLINFO_RESPONSE_CODE, &_responseCode);', "\n";
   print "\n";
   print '            curl_easy_getinfo(_curlHandle, CURLINFO_TOTAL_TIME, &_fetchTime);', "\n";
   print "\n";
   print '#if 0', "\n";
   print '            printf(">>>>>>>>>>>>>>>>>>> target URL %s\\n", _targetURL.c_str());', "\n";
   print '            printf(">>>>>>>>>>>>>>>> effective URL %s\\n", _effectiveURL.c_str());', "\n";
   print '            printf(">>>>>>>>>>>>>>>> content type %s\\n", _contentType.c_str());', "\n";
   print '            printf(">>>>>>>>>>>>>>>> response code is %d\\n", _responseCode);', "\n";
   print '            printf(">>>>>>>>>>>>>>>> total time is %lf\\n", _fetchTime);', "\n";
   print '#endif', "\n";
   print "\n";
   print '            long lastModTime;', "\n";
   print '            rc2 = curl_easy_getinfo(_curlHandle, CURLINFO_FILETIME, &lastModTime);', "\n";
   print '            if (rc2==CURLE_OK)', "\n";
   print '              {', "\n";
   print '                if (_incrementalFetch) // incremental mode', "\n";
   print '                  {', "\n";
   print '                    //  If the retrieval buffer is a superset of the cached file,', "\n";
   print '                    //   return the portion that is a proper superset (may be empty)', "\n";
   print '                    //  Else return the retrieval buffer', "\n";
   print "\n";
   print '                    size_t bufSize = _curlBuffer.size();', "\n";
   print '                    size_t cacheSize = _fileCache.size();', "\n";
   print "\n";
   print '                    // If the cache is empty and the retrieval buffer is not, return the entire buffer.', "\n";
   print '                    if (cacheSize == 0 && bufSize > 0)', "\n";
   print '                      result = _curlBuffer;', "\n";
   print "\n";
   print '                    // If the retrieval buffer is smaller than the cached file, we take that as', "\n";
   print '                    // a signal that the file was completely refreshed, so return the entire buffer.', "\n";
   print '                    else if (bufSize < cacheSize)', "\n";
   print '                      result = _curlBuffer;', "\n";
   print "\n";
   print '                    // At this point, we know the buffer is the same size as the cached file,', "\n";
   print '                    // or it is larger.', "\n";
   print "\n";
   print '                    else if (bufSize == cacheSize)', "\n";
   print '                    // Files are same size.', "\n";
   print '                      {', "\n";
   print "\n";
   print '                        // If cache and buffer have the same content, return empty string', "\n";
   print '                        // Otherwise return retrieval buffer', "\n";
   print '                        if (_curlBuffer.compare(_fileCache) == 0)', "\n";
   print '                          result.clear();', "\n";
   print '                        else', "\n";
   print '                          result = _curlBuffer;', "\n";
   print '                      }', "\n";
   print "\n";
   print '                    else', "\n";
   print '                    // The buffer is larger than the cached file.', "\n";
   print '                      {', "\n";
   print '                        if (_curlBuffer.substr(0, cacheSize).compare(_fileCache)', "\n";
   print '                            == 0)', "\n";
   print '                          result = _curlBuffer.substr(cacheSize);', "\n";
   print '                        else', "\n";
   print '                          result = _curlBuffer;', "\n";
   print '                      }', "\n";
   print '                  }', "\n";
   print "\n";
   print '                else // not incremental mode, return the retrieval buffer', "\n";
   print '                  {', "\n";
   print '                    result = _curlBuffer;', "\n";
   print '                  }', "\n";
   print "\n";
   print '                //   Replace the file cache with the retrieval buffer', "\n";
   print '                _fileCache = _curlBuffer;', "\n";
   print '                // Resync the last modified time', "\n";
   print '                _lastModTime = lastModTime;', "\n";
   print '              }', "\n";
   print '            else', "\n";
   print '            // rc from getting the last mod time was nonzero', "\n";
   print "\n";
   print '              {', "\n";
   print '                throw rc2;', "\n";
   print '              }', "\n";
   print '          } // data came back', "\n";
   print "\n";
   print '        else // no data came back', "\n";
   print "\n";
   print '          {', "\n";
   print '            long lastModTime;', "\n";
   print '            CURLcode rc2 = curl_easy_getinfo(_curlHandle, CURLINFO_FILETIME, &lastModTime);', "\n";
   print '            if (CURLE_OK == rc2)', "\n";
   print '              {', "\n";
   print '                // Leave the cached version of the file as-is', "\n";
   print '                // If incremental mode, return an empty string', "\n";
   print '                // Otherwise return the complete file value (our cached version of the file)', "\n";
   print '                if (_incrementalFetch)', "\n";
   print '                  result.clear();', "\n";
   print '                else', "\n";
   print '                  result = _fileCache;', "\n";
   print "\n";
   print '                // Resync the last modified time', "\n";
   print '                if (lastModTime > -1)', "\n";
   print '                  _lastModTime = lastModTime;', "\n";
   print "\n";
   print '              }', "\n";
   print '            else', "\n";
   print '              {', "\n";
   print '                throw rc2;', "\n";
   print '              }', "\n";
   print '          }', "\n";
   print '      }', "\n";
   print '    else // rc from performing the fetch was nonzero', "\n";
   print "\n";
   print '      {', "\n";
   print '        throw rc1;', "\n";
   print '      }', "\n";
   print '    return result;', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::reset()', "\n";
   print '  {', "\n";
   print '    _bytesTransferredTotal = _bytesTransferredLastFetch = 0;', "\n";
   print '    _curlBuffer.clear();', "\n";
   print '    _fileCache.clear();', "\n";
   print '    _lastModTime = -1;', "\n";
   print '    _dataCameBack = false;', "\n";
   print '    _responseCode = 0;', "\n";
   print '    _fetchTime = 0;', "\n";
   print '    _effectiveURL.clear();', "\n";
   print '    _contentType.clear();', "\n";
   print '  }', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::targetURL() const', "\n";
   print '  {', "\n";
   print '    return _targetURL;', "\n";
   print '  }', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::effectiveURL() const', "\n";
   print '  {', "\n";
   print '    return _effectiveURL;', "\n";
   print '  }', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::contentType() const', "\n";
   print '  {', "\n";
   print '    return _contentType;', "\n";
   print '  }', "\n";
   print "\n";
   print 'long MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::responseCode() const', "\n";
   print '  {', "\n";
   print '    return _responseCode;', "\n";
   print '  }', "\n";
   print "\n";
   print 'double MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::fetchTime() const', "\n";
   print '  {', "\n";
   print '    return _fetchTime;', "\n";
   print '  }', "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::updateURL(std::string newURL) {', "\n";
   print '    if (newURL != _targetURL) {', "\n";
   print '        reset();', "\n";
   print '        _targetURL = newURL;', "\n";
   print '        curl_easy_setopt(_curlHandle, CURLOPT_URL, newURL.c_str());', "\n";
   print '        return true;', "\n";
   print '    }', "\n";
   print '    return false;', "\n";
   print '  }', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::lastknownContents() const', "\n";
   print '  {', "\n";
   print '    return _fileCache;', "\n";
   print '  }', "\n";
   print "\n";
   print 'size_t MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::bytesTransferredTotal()', "\n";
   print '  {', "\n";
   print '    return _bytesTransferredTotal;', "\n";
   print '  }', "\n";
   print "\n";
   print 'size_t MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::bytesTransferredLastFetch()', "\n";
   print '  {', "\n";
   print '    return _bytesTransferredLastFetch;', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::enableCurlTrace()', "\n";
   print '  {', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_VERBOSE, 1);', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::disableCurlTrace()', "\n";
   print '  {', "\n";
   print '    curl_easy_setopt(_curlHandle, CURLOPT_VERBOSE, 0);', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::incrementalFetch()', "\n";
   print '  {', "\n";
   print '    _incrementalFetch = true;', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::incrementalFetch(bool whether)', "\n";
   print '  {', "\n";
   print '    _incrementalFetch = whether;', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::ignoreLastModTime()', "\n";
   print '  {', "\n";
   print '    _ignoreLastModTime = true;', "\n";
   print '  }', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::ignoreLastModTime(bool whether)', "\n";
   print '  {', "\n";
   print '    _ignoreLastModTime = whether;', "\n";
   print '  }', "\n";
   print "\n";
   print 'CURL* MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::curlHandle()', "\n";
   print '  {', "\n";
   print '    return _curlHandle;', "\n";
   print '  }', "\n";
   print "\n";
   print 'size_t MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::consumeData_static(void* buffer, const size_t recSize,', "\n";
   print '    const size_t numRecs, void* objPtr)', "\n";
   print '  {', "\n";
   print '    // Adapt the static callback from cURL to a non-static member function of this object instance', "\n";
   print '    return static_cast<InetRetriever*> (objPtr)->consumeData(buffer, recSize,', "\n";
   print '        numRecs);', "\n";
   print '  }', "\n";
   print "\n";
   print 'size_t MY_OPERATOR_SCOPE::MY_OPERATOR::InetRetriever::consumeData(const void* data, const size_t recSize,', "\n";
   print '    const size_t numRecs)', "\n";
   print '// Note: this method might be invoked many times by curl during a single fetch.  Each invocation', "\n";
   print '// supplies a chunk of the fetched data, and this method must assemble all the chunks.', "\n";
   print "\n";
   print '  {', "\n";
   print '    // Flag that some data came back', "\n";
   print '    _dataCameBack = true;', "\n";
   print "\n";
   print '    // Compute # of bytes in this chunk and increment counters accordingly', "\n";
   print '    size_t chunkSize = recSize * numRecs;', "\n";
   print '    _bytesTransferredTotal += chunkSize;', "\n";
   print '    _bytesTransferredLastFetch += chunkSize;', "\n";
   print "\n";
   print '    // Append the chunk to the curlBuffer', "\n";
   print '    _curlBuffer.append((char*) data, chunkSize);', "\n";
   print "\n";
   print '    // Curl requires that this function return the # of bytes processed during this invocation', "\n";
   print '    return chunkSize;', "\n";
   print '  }', "\n";
   print '/*', "\n";
   print '*******************************************************************************', "\n";
   print '* Copyright (C) 2007, 2012-2014, International Business Machines Corporation. ', "\n";
   print '* All Rights Reserved. *', "\n";
   print '*******************************************************************************', "\n";
   print '*/', "\n";
   print "\n";
   print '// This is the file containing the URIHelper code.', "\n";
   print '// The file is meant to be included in a CGT file (it references MY_OPERATOR)', "\n";
   print '// ', "\n";
   print "\n";
   print "\n";
   print '#include <iostream>', "\n";
   print '#include <cstring>', "\n";
   print '#include <regex.h>', "\n";
   print '#include <vector>', "\n";
   print '#include <sstream>', "\n";
   print "\n";
   print "\n";
   print 'using namespace std;', "\n";
   print "\n";
   print '//---- URIQueryComponents class', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::URIQueryComponents::print(ostream& o) const {', "\n";
   print '  for(std::map<string, string>::const_iterator i=nameValuePairs.begin();', "\n";
   print '    i!=nameValuePairs.end();++i) {', "\n";
   print '    o << "name: \'" << i->first', "\n";
   print '      << "\' value: \'" << i->second', "\n";
   print '      << "\' ";', "\n";
   print '  }', "\n";
   print '}', "\n";
   print "\n";
   print 'ostream& operator<< (ostream& o, const MY_OPERATOR_SCOPE::MY_OPERATOR::URIQueryComponents& qc) {', "\n";
   print '  qc.print(o);', "\n";
   print '  return o;', "\n";
   print '}', "\n";
   print "\n";
   print '//---- URIHelper class', "\n";
   print "\n";
   print '// subset regex of URI defined in RFC 2396', "\n";
   print 'const char* MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::URIREGEX=', "\n";
   print '  /* protocol (opt) */ \\', "\n";
   print '  "^(([[:alpha:]][[:alnum:]+.-]*):)?" \\', "\n";
   print '  /* userinfo (opt) */ \\', "\n";
   print '  "//(([[:alnum:]@_.!~*\\\'();:&=+$,-]*)@)?" \\', "\n";
   print '  /* hostname (opt) */ \\', "\n";
   print '  "(((([[:alnum:]]|[[:alnum:]][[:alnum:]-]*[[:alnum:]])\\\\.)*" \\', "\n";
   print '  "([[:alpha:]]|[[:alpha:]][[:alnum:]-]*[[:alnum:]]))\\\\.?|" \\', "\n";
   print '  /* IPv4address */ \\', "\n";
   print '  "([[:digit:]]+\\\\.[[:digit:]]+\\\\.[[:digit:]]+\\\\.[[:digit:]]+))?" \\', "\n";
   print '  /* port (opt) */ \\', "\n";
   print '  "(:([[:digit:]]+))?" \\', "\n";
   print '  /* path (opt) */ \\', "\n";
   print '  "/(([[:alnum:]_.!~*\\\'():@&=+$,-]|%[[:digit:]a-fA-F][[:digit:]a-fA-F])*" \\', "\n";
   print '  "(;([[:alnum:]_.!~*\\\'():@&=+$,-]|%[[:digit:]a-fA-F][[:digit:]a-fA-F])*)*" \\', "\n";
   print '  "(/([[:alnum:]_.!~*\\\'():@&=+$,-]|%[[:digit:]a-fA-F][[:digit:]a-fA-F])*" \\', "\n";
   print '  "(;([[:alnum:]_.!~*\\\'():@&=+$,-]|%[[:digit:]a-fA-F][[:digit:]a-fA-F])*)*" ")*" ")" \\', "\n";
   print '  /* query (opt) */ \\', "\n";
   print '  "(\\\\?([[:alnum:]_.!~*\\\'():@&=+$,;/?:@&=+$,-]|%[[:digit:]a-fA-F][[:digit:]a-fA-F])*)?$";', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::URIHelper(void) : proto(UNDEFINED), portnum(-1) {', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::URIHelper(const string& uri) : proto(UNDEFINED), portnum(-1) {', "\n";
   print '  init(uri);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::init(const string& uri) {', "\n";
   print '  string str=trim(uri);', "\n";
   print '    if (!parseURI(str)) {', "\n";
   print '      ostringstream err;', "\n";
   print '      err << "URI is not syntatically correct \'" << uri << "\'";', "\n";
   print '      throw std::exception();', "\n";
   print '   }', "\n";
   print '  if (protocol == "file") {', "\n";
   print '    proto=FILE;', "\n";
   print '  }', "\n";
   print '  else if (protocol == "http" || protocol == "https") {', "\n";
   print '    proto=HTTP;', "\n";
   print '  }', "\n";
   print '  else if (protocol == "ftp" || protocol == "ftps") {', "\n";
   print '    proto=FTP;', "\n";
   print '  }', "\n";
   print '  else if (!protocol.empty()) {', "\n";
   print '    ostringstream err;', "\n";
   print '    err << "Protocol not supported: \'" << protocol << "\'";', "\n";
   print '    throw std::exception();', "\n";
   print '  }', "\n";
   print '  if (!port.empty())', "\n";
   print '    fromString<int>(portnum,port);', "\n";
   print '}', "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::parseURI(const string& uri) {', "\n";
   print '  regex_t reg;', "\n";
   print '  regmatch_t match[NMATCH];', "\n";
   print "\n";
   print '  if(uri.empty())', "\n";
   print '    return false;', "\n";
   print "\n";
   print '  int ret1=regcomp(&reg, URIREGEX, REG_EXTENDED);', "\n";
   print '  int ret2=regexec(&reg, uri.c_str(), NMATCH, match, 0);', "\n";
   print '  regfree(&reg);', "\n";
   print "\n";
   print '  if(ret1 != 0 || ret2 != 0) {', "\n";
   print '    return false;', "\n";
   print '  }', "\n";
   print "\n";
   print '  if (match[SCHEME_NUM].rm_so > -1) {', "\n";
   print '    char temp[match[SCHEME_NUM].rm_eo-match[SCHEME_NUM].rm_so+1];', "\n";
   print '    memset(temp,0,match[SCHEME_NUM].rm_eo-match[SCHEME_NUM].rm_so+1);', "\n";
   print '    strncpy(temp, uri.c_str() + match[SCHEME_NUM].rm_so,', "\n";
   print '	     match[SCHEME_NUM].rm_eo-match[SCHEME_NUM].rm_so);', "\n";
   print '    protocol.assign(temp);', "\n";
   print '  }', "\n";
   print "\n";
   print '  if (match[USERINFO_NUM].rm_so > -1) {', "\n";
   print '    char temp[match[USERINFO_NUM].rm_eo-match[USERINFO_NUM].rm_so+1];', "\n";
   print '    memset(temp,0,match[USERINFO_NUM].rm_eo-match[USERINFO_NUM].rm_so+1);', "\n";
   print '    strncpy(temp, uri.c_str() + match[USERINFO_NUM].rm_so,', "\n";
   print '	     match[USERINFO_NUM].rm_eo-match[USERINFO_NUM].rm_so);', "\n";
   print '    userinfo.assign(temp);', "\n";
   print '  }', "\n";
   print "\n";
   print '  if (match[HOST_NUM].rm_so > -1) {', "\n";
   print '    char temp[match[HOST_NUM].rm_eo-match[HOST_NUM].rm_so+1];', "\n";
   print '    memset(temp,0,match[HOST_NUM].rm_eo-match[HOST_NUM].rm_so+1);', "\n";
   print '    strncpy(temp, uri.c_str() + match[HOST_NUM].rm_so,', "\n";
   print '	     match[HOST_NUM].rm_eo-match[HOST_NUM].rm_so);', "\n";
   print '    host.assign(temp);', "\n";
   print '  }', "\n";
   print "\n";
   print '  if (match[PORT_NUM].rm_so > -1) {', "\n";
   print '    char temp[match[PORT_NUM].rm_eo-match[PORT_NUM].rm_so+1];', "\n";
   print '    memset(temp,0,match[PORT_NUM].rm_eo-match[PORT_NUM].rm_so+1);', "\n";
   print '    strncpy(temp, uri.c_str() + match[PORT_NUM].rm_so,', "\n";
   print '	     match[PORT_NUM].rm_eo-match[PORT_NUM].rm_so);', "\n";
   print '    port.assign(temp);', "\n";
   print '  }', "\n";
   print "\n";
   print '  if (match[PATH_NUM].rm_so > -1) {', "\n";
   print '    char temp[match[PATH_NUM].rm_eo-match[PATH_NUM].rm_so+1];', "\n";
   print '    memset(temp,0,match[PATH_NUM].rm_eo-match[PATH_NUM].rm_so+1);', "\n";
   print '    strncpy(temp, uri.c_str() + match[PATH_NUM].rm_so,', "\n";
   print '	     match[PATH_NUM].rm_eo-match[PATH_NUM].rm_so);', "\n";
   print '    path.assign(temp);', "\n";
   print '  }', "\n";
   print "\n";
   print '  if (match[QUERY_NUM].rm_so > -1) {', "\n";
   print '    char temp[match[QUERY_NUM].rm_eo-match[QUERY_NUM].rm_so+1];', "\n";
   print '    memset(temp,0,match[QUERY_NUM].rm_eo-match[QUERY_NUM].rm_so+1);', "\n";
   print '    strncpy(temp, uri.c_str() + match[QUERY_NUM].rm_so,', "\n";
   print '	     match[QUERY_NUM].rm_eo-match[QUERY_NUM].rm_so);', "\n";
   print '    query.assign(temp);', "\n";
   print '    retrieveQueryComponents();', "\n";
   print '  }', "\n";
   print "\n";
   print '  return true;', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::tokenize(const string& str, vector<string>& tokens,', "\n";
   print '              const string& delimiters, bool keepEmptyTokens) {', "\n";
   print '  // Cleanup', "\n";
   print '  tokens.clear();', "\n";
   print "\n";
   print '  string::size_type lastPos=0;', "\n";
   print '  ', "\n";
   print '  // Find first delimiter', "\n";
   print '  string::size_type pos=str.find_first_of(delimiters,lastPos);', "\n";
   print '  while (pos != string::npos) {', "\n";
   print '    // Found a token, add it to the vector', "\n";
   print '    if (pos!=lastPos) {', "\n";
   print '      tokens.push_back(str.substr(lastPos, pos - lastPos));', "\n";
   print '      lastPos=pos+1;', "\n";
   print '    }', "\n";
   print '    else {', "\n";
   print '      if(keepEmptyTokens) ', "\n";
   print '        tokens.push_back("");', "\n";
   print '      lastPos++;', "\n";
   print '    }', "\n";
   print '    // Find next "non-delimiter"', "\n";
   print '    pos = str.find_first_of(delimiters, lastPos);', "\n";
   print '  }', "\n";
   print '  if (lastPos!=str.size()) {', "\n";
   print '    tokens.push_back(str.substr(lastPos));', "\n";
   print '  } else {', "\n";
   print '    if(keepEmptyTokens) ', "\n";
   print '      tokens.push_back("");', "\n";
   print '  }', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::retrieveQueryComponents(void) {', "\n";
   print '  size_t found=query.find_first_of("?");', "\n";
   print '  string parameters(query.substr(found+1));', "\n";
   print '  /*', "\n";
   print '  cout << "---> " << query << endl;', "\n";
   print '  cout << "---> " << parameters << endl;', "\n";
   print '  */', "\n";
   print '  vector<string> tokens;', "\n";
   print '  tokenize(parameters,tokens,"&",false);', "\n";
   print '  for(vector<string>::const_iterator i=tokens.begin(); i!=tokens.end(); ++i) {', "\n";
   print '    vector<string> nameValue;', "\n";
   print '    /*', "\n";
   print '    cout << "-----> " << *i << endl;', "\n";
   print '    */', "\n";
   print '    tokenize(*i,nameValue,"=",false);', "\n";
   print '    if (nameValue.size()==1)', "\n";
   print '      qc.nameValuePairs.insert(make_pair(trim(nameValue[0]),""));', "\n";
   print '    else if (nameValue.size()==2)', "\n";
   print '      qc.nameValuePairs.insert(make_pair(trim(nameValue[0]),trim(nameValue[1])));', "\n";
   print '  }', "\n";
   print '}', "\n";
   print "\n";
   print 'bool MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::isMulticastAddress(void) const {', "\n";
   print '  size_t found=host.find_first_of(".");', "\n";
   print '  if (found==string::npos)', "\n";
   print '    return false;', "\n";
   print '  string fstoctet(host.substr(0,found));', "\n";
   print '  /*', "\n";
   print '  cout << fstoctet << endl;', "\n";
   print '  */', "\n";
   print '  try {', "\n";
   print '    short octet;', "\n";
   print '    fromString(octet,fstoctet);', "\n";
   print '    if (octet>=224 && octet<=239)', "\n";
   print '      return true;', "\n";
   print '  }', "\n";
   print '  catch(...) {', "\n";
   print '    // whatever!', "\n";
   print '  }', "\n";
   print '  return false;', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper::print(ostream& o) const {', "\n";
   print '  o << "protocol: \'" << protocol', "\n";
   print '    << "\' userinfo: \'" << userinfo', "\n";
   print '    << "\' host: \'" << host', "\n";
   print '    << "\' port: \'" << port', "\n";
   print '    << "\' path: \'" << path', "\n";
   print '    << "\' query: \'" << query', "\n";
   print '    << "\'";', "\n";
   print '}', "\n";
   print "\n";
   print 'ostream& operator<< (ostream& o, const MY_OPERATOR_SCOPE::MY_OPERATOR::URIHelper& uri) {', "\n";
   print '  uri.print(o);', "\n";
   print '  return o;', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   print "\n";
   print '// This macro wraps the specified line of \'code\' in an \'if\' block that executes', "\n";
   print '// only if the application\'s tracing level is at least as high as the specified \'level\'.', "\n";
   print '// Note that this macro should be defined in \'.../system/impl/include/TRC/DistilleryDebug.h\'', "\n";
   print '// or \'.../include/SPL/Runtime/Common/RuntimeDebug.h\'.', "\n";
   print "\n";
   print '#define SPLAPPTRC_CODE(level, code) do { \\', "\n";
   print '  int ilvl = Distillery::debug::EXTERNAL_DEBUG_LEVEL_MAP_TO_INTERNAL[level]; \\', "\n";
   print '  if ( __builtin_expect( (ilvl <= Distillery::debug::app_trace_level) , 0 ) ) \\', "\n";
   print '  { \\', "\n";
   print '    code ; \\', "\n";
   print '  } \\', "\n";
   print '} while(0)', "\n";
   print "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '  : MY_BASE_OPERATOR(), ', "\n";
   print '    relFileProtocol("file:///"),', "\n";
   print '    absFileProtocol("file:////"),', "\n";
   print '    retrievers_(),', "\n";
   print '    timeout_(';
   print $timeout;
   print '),', "\n";
   print '    retCodeCounts_(),', "\n";
   print '    inputLinesPerRecord_(';
   print (($parameter = $model->getParameterByName("inputLinesPerRecord"))?SPL::CodeGen::getParameterCppInitializer($parameter):1);
   print '), ', "\n";
   print '    intraRecordPadValue_(';
   print (($parameter = $model->getParameterByName("intraRecordPadValue"))?SPL::CodeGen::getParameterCppInitializer($parameter):"\" \"");
   print '), ', "\n";
   print '    fetchInterval_(';
   print (($parameter = $model->getParameterByName("fetchInterval"))?SPL::CodeGen::getParameterCppInitializer($parameter):600.0);
   print '), ', "\n";
   print '    punctPerFetch_(';
   print (($parameter = $model->getParameterByName("punctPerFetch"))?SPL::CodeGen::getParameterCppInitializer($parameter):'false');
   print '), ', "\n";
   print '    iterations_(';
   print (($parameter = $model->getParameterByName("iterations"))?SPL::CodeGen::getParameterCppInitializer($parameter):0);
   print '), ', "\n";
   print '    iteration_(0), ', "\n";
    if ($dataAttributeType eq "list<rstring>") { 
   print "\n";
   print '    emitTuplePerRecordCount_(';
   print ($emitTuplePerRecordCount?SPL::CodeGen::getParameterCppInitializer($emitTuplePerRecordCount):0),;
   print '),', "\n";
    } else { 
   print "\n";
   print '    emitTuplePerRecordCount_(1),', "\n";
    } 
   print "\n";
   print '   dynamicURL_(';
   print ($model->getParameterByName("URIList")->getValueAt(0)->hasSideEffects()?"true":"false");
   print ')', "\n";
   print '{', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::addRetriever(const std::string&  url, const int timeout) {', "\n";
   print "\n";
   print '      SPLAPPTRC(L_DEBUG, "Using \'" << url << "\' as a target URL ...","InetSource");', "\n";
   print "\n";
   print '      // allocate a curl object for this URL', "\n";
   print '      InetRetriever* retriever = new InetRetriever(url, timeout);', "\n";
   print "\n";
   print '      // enable tracing in curl object if this operator is tracing', "\n";
   print '      SPLAPPTRC_CODE( L_TRACE, retriever->enableCurlTrace() );', "\n";
   print "\n";
    if($incrementalFetch) { 
   print "\n";
   print '      retriever->incrementalFetch(';
   print $incrementalFetch;
   print ');', "\n";
    } 
   print "\n";
    if($unconditionalFetch) { 
   print "\n";
   print '      retriever->ignoreLastModTime(';
   print $unconditionalFetch;
   print ');', "\n";
    } 
   print "\n";
   print '      std::pair<int, uint32_t> retcodeCount (0, 0);', "\n";
   print '      retrievers_.push_back(retriever);', "\n";
   print '      retCodeCounts_.push_back(retcodeCount);', "\n";
   print '     ', "\n";
   print '}', "\n";
   print "\n";
   print 'std::string MY_OPERATOR_SCOPE::MY_OPERATOR::checkURI(const std::string & url) {', "\n";
   print '    URIHelper uri;', "\n";
   print '    try', "\n";
   print '    {', "\n";
   print '      // Ensure that the URI is correctly formatted', "\n";
   print '      uri.init(url);', "\n";
   print '    }', "\n";
   print '    catch(DistilleryException& e) ', "\n";
   print '    {', "\n";
   print '      // Malformed input URL -- log error and return empty string', "\n";
   print '      SPLAPPTRC(L_ERROR, "malformed URL " << url, "InetSource");', "\n";
   print '      return std::string();', "\n";
   print '    }', "\n";
   print '    catch(std::exception& e) ', "\n";
   print '    {', "\n";
   print '      // Malformed input URL -- log error and return empty string', "\n";
   print '      SPLAPPTRC(L_ERROR, "malformed URL " << url, "InetSource");', "\n";
   print '      return std::string();', "\n";
   print '    }', "\n";
   print "\n";
   print '    if((url.compare(0, 8, relFileProtocol) == 0) && (url.compare(0, 9, absFileProtocol) != 0))', "\n";
   print '    // The URI was declared as a relative path/filename (relative to the PE\'s data directory).', "\n";
   print '    // Compute the absolute path/filename and assign it back to URL. ', "\n";
   print '    {', "\n";
   print '      string iFileName;', "\n";
   print '      iFileName.assign(uri.getPath());', "\n";
   print '      trim(iFileName);', "\n";
   print "\n";
   print '      // get the real path (i.e. resolve any symlinks to actual filename)', "\n";
   print '      char* rp = new char[PATH_MAX+1];', "\n";
   print '      memset(rp, 0x00, PATH_MAX+1);', "\n";
   print "\n";
   print '      string rn;', "\n";
   print '      if(realpath(iFileName.c_str(), rp))', "\n";
   print '      {', "\n";
   print '        rn = string(rp);', "\n";
   print '      }', "\n";
   print '      delete [] rp;', "\n";
   print "\n";
   print '      string inputFileName;', "\n";
   print '      if(iFileName == rn)', "\n";
   print '      {', "\n";
   print '        inputFileName = rn;', "\n";
   print '      }', "\n";
   print '      else', "\n";
   print '      {', "\n";
   print '        inputFileName.append(getPE().getDataDirectory());', "\n";
   print '        inputFileName.append("/").append(iFileName);', "\n";
   print '      }', "\n";
   print "\n";
   print '      std::string newURL(relFileProtocol);', "\n";
   print '      newURL.append(inputFileName);', "\n";
   print '      return newURL;', "\n";
   print '    }', "\n";
   print '    else {', "\n";
   print '        return url;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '  for(std::size_t i = 0; i < retrievers_.size(); i++)', "\n";
   print '  {', "\n";
   print '    InetRetriever* retriever = retrievers_.at(i);', "\n";
   print '    delete retriever;', "\n";
   print '  }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '  createThreads(1); // for now, single-threaded only', "\n";
   print '}', "\n";
   print ' ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '  SPLAPPTRC(L_TRACE, "Shutdown Request event received by PE " << getContext().getName(), "InetSource");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '  SPLAPPTRC(L_TRACE, "Processing...", "InetSource");', "\n";
   print "\n";
   print '  bool ignoreURIcheckException = ';
   print $ignoreURIcheckException;
   print ';', "\n";
   print '  std::string fetchContent; // content fetched from URL', "\n";
   print '  std::istringstream fetchBuffer; // buffer of content fetched from URL', "\n";
   print "\n";
    if($doNotStreamInitialFetch) { 
   print "\n";
   print '  // do not emit tuples for initial fetch', "\n";
   print '  bool initialFetch = true;', "\n";
    } 
   print "\n";
   print "\n";
    if ($dataAttributeType eq "list<rstring>") { 
   print "\n";
   print '  // internal buffer for accumulating lines for output records', "\n";
   print '  SPL::list<SPL::rstring> recordBuffer;', "\n";
   print '  int recordCounter = 0;', "\n";
    } 
   print "\n";
   print "\n";
    if($initDelay) { 
   print "\n";
   print '  // initial delay', "\n";
   print '  getPE().blockUntilShutdownRequest(';
   print $initDelay;
   print ');', "\n";
    } 
   print "\n";
   print '  ', "\n";
   print '  bool firstTime = true;', "\n";
   print '  while(!getPE().getShutdownRequested())', "\n";
   print '  {', "\n";
   print "\n";
   print '    if (dynamicURL_ || firstTime) {', "\n";
   print '      firstTime = false;', "\n";
   print "\n";
   print '      // Make the list with the checked uris to get the real number of required retrievers', "\n";
   print '      SPL::list<SPL::rstring> newURIChecked;', "\n";
   print '      {', "\n";
   print '        // get list or URIs', "\n";
   print '        SPL::list<SPL::rstring> newURI = ';
   print ($model->getParameterByName("URIList")->getValueAt(0)->getCppExpression());
   print ';', "\n";
   print '        bool oops = false;', "\n";
   print '        for (std::size_t i = 0; i < newURI.size(); i++) {', "\n";
   print '          std::string uri = checkURI(newURI.at(i));', "\n";
   print '          if (uri.length()==0) {', "\n";
   print '            if (ignoreURIcheckException) {', "\n";
   print '              uri = newURI.at(i);', "\n";
   print '              SPLAPPTRC(L_WARN, "Use uri after failed uri check! URL=" << uri, "InetSource");', "\n";
   print '            } else {', "\n";
   print '              oops = true;', "\n";
   print '              SPLAPPTRC(L_ERROR, "ignoring malformed URL=" << newURI.at(i), "InetSource");', "\n";
   print '              continue;', "\n";
   print '            }', "\n";
   print '          }', "\n";
   print '          newURIChecked.push_back(uri);', "\n";
   print '        }', "\n";
   print '        // terminate if any of the URIs are invalid and won\'t change, otherwise continue with valid URIs', "\n";
   print '        if ( oops && !dynamicURL_ ) {', "\n";
   print '          SPLAPPTRC(L_ERROR, INET_MALFORMED_URI, "InetSource");', "\n";
   print '          SPL::Functions::Utility::abort(__FILE__, __LINE__);', "\n";
   print '        }', "\n";
   print '      }', "\n";
   print "\n";
   print '      // delete retrievers we won\'t need.', "\n";
   print '      while (retrievers_.size() > newURIChecked.size()) {', "\n";
   print '        // save it so we can delete it.', "\n";
   print '        InetRetriever* last = retrievers_.back();', "\n";
   print '        retrievers_.erase(retrievers_.end() -1, retrievers_.end());', "\n";
   print '        retCodeCounts_.erase(retCodeCounts_.end() -1, retCodeCounts_.end());', "\n";
   print '        delete last;', "\n";
   print '      }', "\n";
   print "\n";
   print '      // If there\'s a retriever, re-use it.', "\n";
   print '      for (std::size_t i = 0; i < retrievers_.size() ; i++)  {', "\n";
   print '        if (retrievers_.at(i)->updateURL(newURIChecked.at(i))) {', "\n";
   print '          SPLAPPTRC(L_INFO, "URL " << i << " updated to " << retrievers_.at(i)->targetURL(), "InetSource");', "\n";
   print '        }', "\n";
   print '        else {', "\n";
   print '          SPLAPPTRC(L_DEBUG,"URL " << i << " re-evaluated, but is unchanged ", "InetSource");', "\n";
   print '        }', "\n";
   print '      } // end -- check URLs in list of \'retrievers\' ', "\n";
   print "\n";
   print '      // add a retriever for a new URI', "\n";
   print '      for (std::size_t i = retrievers_.size(); i < newURIChecked.size(); i++) {', "\n";
   print '        addRetriever(newURIChecked.at(i), timeout_);', "\n";
   print '      }', "\n";
   print '    } // end -- if \'dynamicURL_\' or \'firstTime\'', "\n";
   print "\n";
   print '    // now fetch content from each \'retriever\' and emit zero or more tuples containing its data', "\n";
   print '    for(std::size_t i = 0; i < retrievers_.size() && !getPE().getShutdownRequested(); i++)', "\n";
   print '    {', "\n";
   print "\n";
   print '      // point at the next \'retriever\' object', "\n";
   print '      retriever_ = retrievers_.at(i);', "\n";
   print '      SPLAPPTRC(L_DEBUG, "getting URL " << retriever_->targetURL() << " ...","InetSource");', "\n";
   print "\n";
   print '      // fetch content from this URL ', "\n";
   print '      try', "\n";
   print '      {', "\n";
   print '        fetchContent = retriever_->fetch();', "\n";
   print '      }', "\n";
   print '      catch(CURLcode rc)', "\n";
   print '      {', "\n";
   print '        std::pair<int,uint32_t> & retcodeCount = retCodeCounts_.at(i);', "\n";
   print '        // Keep track of how many times in a row a given retriever has issued the same return code', "\n";
   print '        // This avoids filling up the log with repetitive messages.', "\n";
   print '        if (retcodeCount.first == rc)', "\n";
   print '        {', "\n";
   print '          (retcodeCount.second)++;', "\n";
   print '        }', "\n";
   print '        else', "\n";
   print '        {', "\n";
   print '          retcodeCount.first = rc;', "\n";
   print '          retcodeCount.second = 1;', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        if (retcodeCount.second < 10)', "\n";
   print '        {', "\n";
   print '          SPLAPPLOG(L_ERROR, "URL " << retriever_->targetURL() << " failed, " << string(curl_easy_strerror(rc)) << " (libcurl error code " << rc << ")", "InetSource");', "\n";
   print '        }', "\n";
   print '        else if (retCodeCounts_.at(i).second % 10 == 0) {', "\n";
   print '          SPL::rstring msg = INET_NONZERO_LIBCURL_RC_REPEATED(retriever_->targetURL(), rc, string(curl_easy_strerror(rc)), retcodeCount.second);', "\n";
   print '          SPLAPPLOG(L_WARN, msg, "InetSource");', "\n";
   print '        }', "\n";
   print '        continue;', "\n";
   print '      }', "\n";
   print "\n";
   print '      SPLAPPTRC(L_DEBUG, "got " << fetchContent.length() << " bytes from URL " << retriever_->targetURL() << " ...","InetSource");', "\n";
   print "\n";
    if($doNotStreamInitialFetch) { 
   print "\n";
   print '      // if we don\'t want the initial fetch and we are on that fetch, skip the output', "\n";
   print '      if(!initialFetch)', "\n";
   print '      {', "\n";
    } 
   print "\n";
   print "\n";
   print "\n";
    if ($dataAttributeType eq "rstring" || $dataAttributeType eq "list<rstring>") { 
   print "\n";
   print '        /*', "\n";
   print '         * Split retrieval buffer into separate "input records", each record containing', "\n";
   print '         * "inputlinesPerRecord" lines from the original file, separated by the "intraRecordPadValue"', "\n";
   print '         * value (default pad value is a single blank char)', "\n";
   print '         */', "\n";
   print '        ', "\n";
   print '        // load fetched content into an \'std::istringstream\' buffer, from which it will be parsed into lines', "\n";
   print "\n";
   print '        fetchBuffer.clear(); // also clears eof bit', "\n";
   print '        fetchBuffer.str(fetchContent);', "\n";
   print "\n";
   print '        // Start of loop here, one loop cycle per input record, until retrieval buffer is exhausted', "\n";
   print "\n";
   print '          while(!fetchBuffer.eof())  {', "\n";
   print '              string record;', "\n";
   print '              getline(fetchBuffer,record);', "\n";
   print '      ', "\n";
   print '              // if there\'s no data left, we should exit this loop', "\n";
   print '              if(fetchBuffer.eof() && record.size() == 0) {', "\n";
   print '                 break;', "\n";
   print '              }', "\n";
   print "\n";
   print '           if(inputLinesPerRecord_ > 1)', "\n";
   print '            {', "\n";
   print '              /*', "\n";
   print '               * Here, the user asked for multiple lines per record, so append the contents of the additional', "\n";
   print '               * lines, interspersing a pad value before each append.  (Note, a value less than 1 means', "\n";
   print '               * "put all lines in a single record.")', "\n";
   print '               */', "\n";
   print '              string line;', "\n";
   print '              for(int lc=1; lc<inputLinesPerRecord_ && !fetchBuffer.eof(); ++lc)', "\n";
   print '              {', "\n";
   print '                getline(fetchBuffer, line);', "\n";
   print '                if(line.size() > 0 && !fetchBuffer.eof())', "\n";
   print '                {', "\n";
   print '                  if(record.size() > 0)  // append the pad value if and only if the previous line had content', "\n";
   print '                  {', "\n";
   print '                    record.append(intraRecordPadValue_);', "\n";
   print '                  }', "\n";
   print '                  record.append(line);', "\n";
   print '                }', "\n";
   print '              }', "\n";
   print '            }', "\n";
   print '            else if(inputLinesPerRecord_ == 0)', "\n";
   print '            {', "\n";
   print '              string line;', "\n";
   print '              while(!fetchBuffer.eof())', "\n";
   print '              {', "\n";
   print '                getline(fetchBuffer, line);', "\n";
   print '                if(line.size() > 0)', "\n";
   print '                {', "\n";
   print '                  if(record.size() > 0)  // append the pad value if and only if the previous line had content', "\n";
   print '                  {', "\n";
   print '                    record.append(intraRecordPadValue_);', "\n";
   print '                  }', "\n";
   print '                  record.append(line);', "\n";
   print '                }', "\n";
   print '              }', "\n";
   print '            }', "\n";
   print '    ', "\n";
   print '            // Now that the record has been formed, do the following:', "\n";
   print '    ', "\n";
    if ($dataAttributeType eq "list<rstring>") { 
   print "\n";
   print '            /*', "\n";
   print '             * Here, the output attribute is a list<rstring>, so append the record to the end of', "\n";
   print '             * the internal buffer we\'re building.  (Don\'t submit it yet though.)', "\n";
   print '             * If the resulting attribute would exceed 2^31-1 in length, fragment it into', "\n";
   print '             * multiple list members each 2^31-1 or less in length.  (This is to avoid', "\n";
   print '             * the SPL limit of 2^31 - 1 on string size in tuples.)', "\n";
   print '             */', "\n";
   print '            while(true)', "\n";
   print '            {', "\n";
   print '              string limitStr = record.substr(0, 2147483647); // gets entire record if size < 2^31-1', "\n";
   print '              recordBuffer.add(limitStr);', "\n";
   print '              if(limitStr.size() < record.size()) // did fragmentation occur?', "\n";
   print '              {', "\n";
   print '                record = record.substr(limitStr.size());', "\n";
   print '              }', "\n";
   print '              else break;// when there is no fragmentation, we are done', "\n";
   print '            }', "\n";
   print '            ++recordCounter;', "\n";
   print '  ', "\n";
   print '            if(emitTuplePerRecordCount_ > 0)', "\n";
   print '            {', "\n";
   print '              /*', "\n";
   print '               * Here, emitTuplePerRecordCount was requested, so test to see if the record count is', "\n";
   print '               * large enough for us to emit a tuple.  If it is, then assign the internal list', "\n";
   print '               * buffer(s) to its(their) corresponding tuple attribute(s) and then submit the tuple.', "\n";
   print '               * Clear the internal list buffer(s) and reset the tuple counter.', "\n";
   print '               */', "\n";
   print '              if(recordCounter >= emitTuplePerRecordCount_ && recordBuffer.size() > 0)', "\n";
   print '              {', "\n";
   print '                outputTuple.clear();', "\n";
   print '                outputTuple.set_';
   print $dataAttributeName;
   print '(recordBuffer);', "\n";
   print '                ';
    CodeGenX::assignOutputAttributeValues("outputTuple", $outputPort); 
   print ' ;', "\n";
   print '                SPLAPPTRC(L_TRACE, "Submitting output tuple with \'list<rstring>\' data attribute" << outputTuple, "InetSource");', "\n";
   print '                submit(outputTuple, 0);', "\n";
   print '                recordBuffer.clear();', "\n";
   print '                recordCounter = 0;', "\n";
   print '              }', "\n";
   print '            }', "\n";
    } # end -- if data attribute is list of strings 
   print "\n";
   print "\n";
   print "\n";
    if ($dataAttributeType eq "rstring") { 
   print "\n";
   print '            /*', "\n";
   print '             * Here, the output attribute is a rstring, so assign the record to the rstring tuple', "\n";
   print '             * attribute and submit the tuple.  If the resulting attribute would exceed 2^31-1 in', "\n";
   print '             * length, fragment it into multiple tuples each 2^31-1 or less in length.  (This is to avoid', "\n";
   print '             * the SPL limit of (2^31 - 1) on string size in tuples.)', "\n";
   print '             */', "\n";
   print '            while(true)', "\n";
   print '            {', "\n";
   print '              outputTuple.clear();', "\n";
   print '              string limitStr = record.substr(0, 2147483647); // gets entire record if size < 2^31-1', "\n";
   print '              outputTuple.set_';
   print $dataAttributeName;
   print '(limitStr);', "\n";
   print '              ';
    CodeGenX::assignOutputAttributeValues("outputTuple", $outputPort); 
   print ' ;', "\n";
   print '              SPLAPPTRC(L_TRACE, "Submitting output tuple with \'rstring\' data attribute " << outputTuple, "InetSource");', "\n";
   print '              submit(outputTuple, 0);', "\n";
   print '              if(limitStr.size() < record.size()) // did fragmentation occur?', "\n";
   print '              {', "\n";
   print '                record = record.substr(limitStr.size());', "\n";
   print '              }', "\n";
   print '              else break; // when there is no fragmentation, we are done', "\n";
   print '            }', "\n";
    } # end -- if data attribute is string 
   print "\n";
   print "\n";
   print "\n";
   print '          } // end -- split fetched content into records', "\n";
   print "\n";
   print "\n";
    if ($dataAttributeType eq "list<rstring>" && $emitTuplePerURI) { 
   print "\n";
   print '        /*', "\n";
   print '         * Here, emitTuplePerURI was requested, so flush the internal list buffer(s) into its(their)', "\n";
   print '         * corresponding tuple attribute(s) and then submit the tuple if nonempty.', "\n";
   print '         */', "\n";
   print '        if(recordBuffer.size() > 0)', "\n";
   print '        {', "\n";
   print '          outputTuple.clear();', "\n";
   print '          outputTuple.set_';
   print $dataAttributeName;
   print '(recordBuffer);', "\n";
   print '          ';
    CodeGenX::assignOutputAttributeValues("outputTuple", $outputPort); 
   print ' ;', "\n";
   print '          SPLAPPTRC(L_TRACE, "Submitting output tuple with \'list<rstring>\' data attribute" << outputTuple, "InetSource");', "\n";
   print '          submit(outputTuple, 0);', "\n";
   print '          recordBuffer.clear();', "\n";
   print '          recordCounter = 0;', "\n";
   print '        } // end -- test for non-empty buffer', "\n";
    } 
   print "\n";
   print "\n";
   print "\n";
    } # end -- if data attribute is string or list of strings 
   print "\n";
   print "\n";
   print "\n";
    if ($dataAttributeType eq "blob") { 
   print "\n";
   print '          /*', "\n";
   print '           * Here the data attribute is a blob, so the entire content fetched from the \'retriever\'', "\n";
   print '           * is assigned to the attribute and submitted.', "\n";
   print '          */', "\n";
   print '          outputTuple.clear();', "\n";
   print '          outputTuple.set_';
   print $dataAttributeName;
   print '( SPL::blob( (const unsigned char*)fetchContent.c_str(), fetchContent.length() ) );', "\n";
   print '          ';
    CodeGenX::assignOutputAttributeValues("outputTuple", $outputPort); 
   print ' ;', "\n";
   print '          SPLAPPTRC(L_TRACE, "Submitting output tuple with \'blob\' data attribute " << outputTuple, "InetSource");', "\n";
   print '          submit(outputTuple, 0);', "\n";
    } # end -- if data attribute is blob 
   print "\n";
   print "\n";
   print "\n";
    if ($dataAttributeType eq "xml") { 
   print "\n";
   print '          /*', "\n";
   print '           * Here the data attribute is XML, so the entire content fetched from the \'retriever\'', "\n";
   print '           * is converted to XML, assigned to the attribute, and submitted. Note that XML', "\n";
   print '           * conversion exceptions are caught and logged, and the tuple discarded without', "\n";
   print '           * emitting any output.', "\n";
   print '          */', "\n";
   print '          try {', "\n";
   print '            outputTuple.clear();', "\n";
   print '            outputTuple.set_';
   print $dataAttributeName;
   print '( SPL::xml( "", fetchContent.c_str(), fetchContent.length() ) );', "\n";
   print '            ';
    CodeGenX::assignOutputAttributeValues("outputTuple", $outputPort); 
   print ' ;', "\n";
   print '            SPLAPPTRC(L_TRACE, "Submitting output tuple with \'xml\' data attribute " << outputTuple, "InetSource");', "\n";
   print '            submit(outputTuple, 0);', "\n";
   print '          } catch (const SPL::SPLRuntimeException& e) {', "\n";
   print '            SPLAPPTRC(L_ERROR, "discarded XML data from " << retriever_->targetURL() << " due to " << e.what() << ", " << e.getExplanation(), "InetSource");', "\n";
   print '          }', "\n";
    } # end -- if data attribute is xml 
   print "\n";
   print "\n";
   print "\n";
    if($doNotStreamInitialFetch) { 
   print "\n";
   print '      }', "\n";
    } 
   print "\n";
   print "\n";
   print '    } // end -- fetch content from list of \'retrievers\'', "\n";
   print "\n";
   print "\n";
    if($doNotStreamInitialFetch) { 
   print "\n";
   print '    // if we don\'t want the initial fetch and we are on that fetch, skip the output', "\n";
   print '    if(!initialFetch)', "\n";
   print '    {', "\n";
    } 
   print "\n";
   print "\n";
    if ($dataAttributeType eq "list<rstring>" && $emitTuplePerFetch) { 
   print "\n";
   print '      /*', "\n";
   print '       * emitTuplePerFetch was requested -- so flush the internal list buffer(s) into its(their)', "\n";
   print '       * corresponding tuple attribute(s) and then submit the tuple.', "\n";
   print '       */', "\n";
   print '      if(recordBuffer.size() > 0)', "\n";
   print '      {', "\n";
   print '        outputTuple.clear();', "\n";
   print '        outputTuple.set_';
   print $dataAttributeName;
   print '(recordBuffer);', "\n";
   print '        ';
    CodeGenX::assignOutputAttributeValues("outputTuple", $outputPort); 
   print ' ;', "\n";
   print '        SPLAPPTRC(L_TRACE, "Submitting output tuple " << outputTuple, "InetSource");', "\n";
   print '        submit(outputTuple, 0);', "\n";
   print '        recordBuffer.clear();', "\n";
   print '        recordCounter = 0;', "\n";
   print '      }', "\n";
    } 
   print "\n";
   print '    ', "\n";
   print '    if(punctPerFetch_) {', "\n";
   print '      // punctPerFetch was requested -- so emit a punctuation here', "\n";
   print '      submit(Punctuation::WindowMarker, 0);', "\n";
   print '    }', "\n";
   print "\n";
    if($doNotStreamInitialFetch) { 
   print "\n";
   print '    }', "\n";
   print '    else', "\n";
   print '    {', "\n";
   print '      // It was the initial fetch...so clear the flag for subsequent fetches', "\n";
   print '      initialFetch = false;', "\n";
   print '    }', "\n";
    } 
   print "\n";
   print "\n";
   print '    // if we are not iterating endlessly, increment iteration counter and break out of loop when limit is reached', "\n";
   print '    if ( iterations_ != 0 && ++iteration_ >= iterations_ ) break;', "\n";
   print "\n";
   print '    // Now pause until it is time to perform the next fetch', "\n";
   print '    SPLAPPTRC(L_DEBUG, "waiting " << fetchInterval_ << " seconds before repeating fetches", "InetSource");', "\n";
   print '    getPE().blockUntilShutdownRequest(fetchInterval_);', "\n";
   print "\n";
   print '  } // end -- while !getPE().getShutdownRequested()', "\n";
   print "\n";
   print "\n";
   print '  // emit final punctuation after last fetch iteration', "\n";
   print '  submit(Punctuation::FinalMarker, 0);', "\n";
   print "\n";
   print '  SPLAPPTRC(L_TRACE, "Processing complete", "InetSource");', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
